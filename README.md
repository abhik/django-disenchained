django-disenchained helps you free Django from the shackles of inefficient queries!

## What

The Django ORM is great because it lets you treat a relational database as a collection of objects but it's a leaky abstraction that makes it _very easy_ to write inefficient code. Especially in large codebases where the functions that query the database are far removed from the view (and written by someone else), it's not readily obvious that you're making multiple queries when one would have sufficed.

`disenchained` logs all queries executed during a Django view, management command or any arbitrary function and provides tools to analyze the query log. You can identify long-running queries; duplicate queries; files, functions or specific lines of code that generate lots of queries; and more!

## How it works

`disenchained.panels.UnchainedPanel` defines a custom panel for the
[django-debug-toolbar](https://github.com/django-debug-toolbar/django-debug-toolbar) that saves the query log in a pickle file that can
later be analyzed by other `disenchained` modules. Enabling the panel (see below)
is all it takes to log queries executed during views.

`disenchained.decorators.log_queries` defines a decorator that logs queries
executed by the decorated function.

## Setup and Configuration

1. Install `disenchained` by cloning the git repo and running setup.py or using pip:


    ```sh
    # NOTE: doesn't work yet. Remove this when package added to PyPI
    pip install django-disenchained
    ```


2. Enable the debug toolbar, add the `disenchained.panels.DisenchainedPanel` panel and specify the `DISENCHAINED_DATA_DIRECTORY` parameter. 

    Your `settings.py` should include this:

    ```python

    if 'debug_toolbar' in settings['INSTALLED_APPS']:
        settings['DISENCHAINED_DATA_DIRECTORY'] = "/var/disenchained-data"
        settings['MIDDLEWARE_CLASSES'].append(
            'debug_toolbar.middleware.DebugToolbarMiddleware')

        settings['DEBUG_TOOLBAR_PANELS'] = (
            'disenchained.panels.UnchainedPanel',
            'debug_toolbar.panels.sql.SQLDebugPanel',
        )
    ```

    For every request, the `django-disenchained` will place a pickle file in the `DISENCHAINED_DATA_DIRECTORY` directory with the name `<view_name>.<timetamp>.pickle`.

## Usage: logging queries in a view

After you visit a page, click the `Disenchained` panel in the debug toolbar to get
the full path to the saved pickle file. Or, simply check the directory specified
by `DISENCHAINED_DATA_DIRECTORY`. 

## Usage: logging queries in a function

The following is an example of decorating a Django management command:

```
from django.core.management.base import BaseCommand
from disenchained.decorators import log_queries

from myapp.models import Book
from myapp.utils import sales_summary

class Command(BaseCommand):
    args = ()

    @log_queries('my_command')
    def handle(self, *args, **kwargs):
        for book in Book.objects.all():
            print sales_summary(book)
```

All queries executed during the execution of this command will be logged and
outputted as a pickle file in the directory specified by the
`DISENCHAINED_DATA_DIRECTORY` setting and with the filename
`my_command.<timestamp>.pickle`.

## Usage: analyzing disenchained pickle files

Here's an example analysis with a pickle file generated by the call review view.

```python
>>> from pprint import pprint
>>> from disenchained import DebugFile
>>> from disenchained.query import most_common, where, num_duplicates

>>> debug = DebugFile("/var/disenchained-data/demo.135736049862.pickle")
```
